# -*- coding: utf-8 -*-
"""BD_ML_DarkCovidNet  for binary classes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l5Wo7lsAj9A6YlXWjLGZEEdIA1olrP5F

# Notebook for Covid-19 classifier

### Importing Libraries

In this lesson we will build our first image classifier from scratch, and see if we can achieve world-class results. Let's dive in!

Every notebook starts with the following three lines; they ensure that any edits to libraries you make are reloaded here automatically, and also that any charts or images displayed are shown in this notebook.
"""

# Commented out IPython magic to ensure Python compatibility.
# %reload_ext autoreload
# %autoreload 2
# %matplotlib inline

"""Utiliza la librería de ```fastai```

```fasbook``` está básicamente desarrollada para cubrir la introducción de deep learning usando fastai y pytorch - conjunto de cuadernos que esta preparado y generado por el equipo de fastai

*   **%reload_ext autoreload:** Reload all the underlying library code so that if there is any chnages in the library the most recent one will be loaded. 
*  **%matplotlib inline:** For plotting something within the notebook itself.
*   **fastai:** Is the software/library which we will be using.
"""

from fastai import *
from fastai.vision import *  #computer vision

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')
# %cd /gdrive

# Commented out IPython magic to ensure Python compatibility.
# %ls /content/drive/MyDrive/UTEC-Proyecto/Deep/X-Ray_Image_DataSet/

"""### Looking at the data¶

**Path** object allows us to create path easily and it takes care of os format in the background as well
"""

path = Path('/content/drive/MyDrive/UTEC-Proyecto/Deep/X-Ray_Image_DataSet/Binary/')

"""The main difference between the handling of image classification datasets is the way labels are stored. In this particular dataset, labels are stored in the filenames themselves. We will need to extract them to be able to classify the images into the correct categories. Fortunately, the fastai library has a handy function made exactly for this, `ImageDataBunch.from_name_re` gets the labels from the filenames using a regular expression."""

np.random.seed(41)
data = ImageDataBunch.from_folder(path, train="TRAIN", valid ="VALID", test ="TEST (1)",
        ds_tfms=get_transforms(), size=(256,256), bs=32, num_workers=4).normalize()

data.classes, data.c, len(data.train_ds), len(data.valid_ds),  len(data.test_ds),

"""Modelo Darknet-19 [59] como punto de partida. Darknet-19 es el clasificador
modelo que forma la base de un sistema de detección de objetos en tiempo real llamado YOLO (solo mira una vez). Este sistema tiene la arquitectura de última generación diseñada para la detección de objetos. El clasificador DarkNet se utiliza sobre la base de esta arquitectura exitosa. Diseñamos el Arquitectura DarkCovidNet, inspirada en la arquitectura DarkNet que ha demostrado su eficacia en el aprendizaje profundo, en lugar de construir un modelo a partir de
rasga. Hemos utilizado menos capas y filtros en comparación con las arquitecturas DarkNet originales.
Aumentamos gradualmente el número de filtros, por ejemplo, a 8, 16, 32. Para comprender mejor este nuevo modelo, es útil comprender los conceptos básicos de Darknet-19, que consta de 19 convolucionales capas y cinco capas de agrupación, utilizando Maxpool. Estas capas son capas típicas de CNN con diferentes filtrar números, tamaños y valores de zancada. Deje que la letra C denote una capa convolucional y M denote una capa de Maxpool. Como C1 se toma como la capa de entrada, Darknet-19 tiene un diseño de capa de la siguiente manera:
"""

print("Number of examples in training:", len(data.train_ds))
print("Number of examples in validation:", len(data.valid_ds))
print("Number of examples in validation:", len(data.test_ds))

xb,yb = data.one_batch()
xb.shape,yb.shape

data.show_batch(rows=3, figsize=(10,10))

"""## DarkCovidNet (modified Darknet model)"""

def conv_block(ni, nf, size=3, stride=1):
    for_pad = lambda s: s if s > 2 else 3
    return nn.Sequential(
        nn.Conv2d(ni, nf, kernel_size=size, stride=stride,
                  padding=(for_pad(size) - 1)//2, bias=False), 
        nn.BatchNorm2d(nf),
        nn.LeakyReLU(negative_slope=0.1, inplace=True)  
    )

def triple_conv(ni, nf):
    return nn.Sequential(
        conv_block(ni, nf),
        conv_block(nf, ni, size=1),  
        conv_block(ni, nf)
    )

def maxpooling():
    return nn.MaxPool2d(2, stride=2)

model = nn.Sequential(
    conv_block(3, 8),
    maxpooling(),
    conv_block(8, 16),
    maxpooling(),
    triple_conv(16, 32),
    maxpooling(),
    triple_conv(32, 64),
    maxpooling(),
    triple_conv(64, 128),
    maxpooling(),
    triple_conv(128, 256),
    conv_block(256, 128, size=1),
    conv_block(128, 256),
    conv_layer(256, 2),
    Flatten(),
    nn.Linear(338, 2)
)

learn = Learner(data, model, loss_func = nn.CrossEntropyLoss(), metrics=accuracy)

print(learn.summary())

learn.fit_one_cycle(100, max_lr=3e-3)

learn.save(path/'model_DarkCovitNet_Binary_08182021', return_path=True)

learn.export()

learn.recorder.plot_losses()

learn.recorder.plot_lr()

learn.recorder.plot_lr(show_moms=True)

learn.recorder.plot_metrics()

learn.show_results(rows=3)

learn.show_results()

print("Number of examples in testing:", len(data.valid_ds))

probs,targets = learn.get_preds(ds_type=DatasetType.Valid)

accuracy(probs,targets)

data.classes, data.c, len(data.train_ds), len(data.valid_ds)

probs = np.argmax(probs, axis=1)
correct = 0
for idx, pred in enumerate(probs):
    if pred == targets[idx]:
        correct += 1
accuracy = correct / len(probs)
print(len(probs), correct, accuracy)

from sklearn.metrics import confusion_matrix
np.set_printoptions(threshold=np.inf) 
cm1 = confusion_matrix(targets, probs)
print(cm1)

from sklearn.metrics import classification_report
y_true1 = targets
y_pred1 = probs
target_names = ['Covid-19', 'No_findings']
print(classification_report(y_true1, y_pred1, target_names=target_names))

interp_dark = ClassificationInterpretation.from_learner(learn)

interp_dark.most_confused(min_val=2)

interp_dark.plot_top_losses(9,figsize=(15,11))

cm_fig = interp_dark.plot_confusion_matrix(return_fig=True)
ax = cm_fig.gca()
ax.set_ylim(interp_dark.data.c - .5, - .5);

from sklearn.metrics import roc_curve
false_positive_rate, true_positive_rate, threshold = roc_curve(y_true1,
                                                               y_pred1)
# Plot ROC curve
plt.title("Receiver Operating Characteristic")
plt.plot(false_positive_rate, true_positive_rate)
plt.plot([0, 1], ls="--")
plt.plot([0, 0], [1, 0] , c=".7"), plt.plot([1, 1] , c=".7")
plt.ylabel("True Positive Rate")
plt.xlabel("False Positive Rate")
plt.show()

learn.recorder.plot_lr()

########################################3333

help(fastbook)

#learn_test = learn.load(path/'model_DarkCovitNet_Binary_08182021')

#learn_test.export(path/'model_DarkCovitNet_Binary_08182021')

path_ = '/content/drive/MyDrive/UTEC-Proyecto/Deep/X-Ray_Image_DataSet/Binary/'

test = ImageList.from_folder(f'{path_}TEST (1)')

test

learn_ = load_learner(path,test=test).load('/content/drive/MyDrive/UTEC-Proyecto/Deep/X-Ray_Image_DataSet/Binary/model_DarkCovitNet_Binary_08182021')

log_preds,targets_ = learn_.get_preds(ds_type=DatasetType.Test)

targets_

accuracy(log_preds,targets_)

preds=np.argmax(log_preds,axis=1)

preds_=np.argmax(log_preds,axis=0)

targets[:10]

log_preds[:10]

preds_[:10]

preds[:10]

fnames = [f.name[:-4] for f in learn_.data.test_ds.items]

df_sub = pd.DataFrame({'id':fnames,'label':preds},columns=['id','label'])

df_sub.head()

df_sub.to_csv(f'{path_}submission.csv',index=False)

learn_.data.classes

